标题/n ,/w 标题/n 链接/n ,/w search/en -/w detail/en ,/w limit/en _/0 width/en 1/m ,/w https/en ,/w 作者/n ,/w 日期/n ,/w https/en 1/m ,/w down/en ,/w 详情/n 标题/n ,/w 日期/n 时间/n ,/w 内容/n
人工智能/n ,/w https://blog.csdn.net/qq_43167223/article/details/83244956/url ,/w init/en (/w )/w 方法/n n/n 需求/n ：/w 在/d 上一/nz 小节/n 的/u demo/n 中/f ，/w 我们/r 已经/d 给/v BMW/n 这个/r 对象/n 添加/v 了/dg 2/m 个/q 属性/n ，/w wheelNum/en （/w 车/np 的/u 轮胎/np 数量/n ）/w 以及/c color/en （/w 车/np 的/u 颜色/n ）/w ，/w 试想/v 如果/c 再次/d 创建/v 一个/mq 对象/n 的话/u ，/w 肯定/a 也/d 需要/n 进行/v 添加/v 属性/n ，/w 显然/a 这样/r 做/v 很/d 费事/a ，/w 那么/c 有没有/vmv 办法/n 能够/v 在/d 创建/v 对象/n 的/u 时候/n ，/w 就/d 顺便/d 把/p 车/np 这个/r 对象/n 的/u 属性/n 给/v 设置/v 呢/ng ？/w n/n 答案/n init/en (/w )/w 方法/n n/n “/w 魔法/n ”/w 方法/n n/n 总结/n n/n 在/d python/en 中方/n 法名/n 如果/c 是/v xxxx/en (/w )/w 的/u ，/w 那么/c 就/d 有/v 特殊/a 的/u 功能/n .../m ,/w https://blog.csdn.net/qq_43167223/article/details/83244956/url ,/w ,/w qq/en _/0 43167223/m ,/w 2018-10-21/t ,/w //blog.csdn.net/qq_43167223/article/details/83244956/url ,/w 270/m 次/a 阅读/v ,/w 人工智能/n -/w qq/en _/0 43167223/m 的/u 博客/n ,/w 2018年10月21日 20:33:55/t ,/w 原/b 人工智能/n



2018年10月21日 20:33:55/t
芜杂/a 栾雨/nr ，/w 芜杂/a 銮舆/n
阅读/v 数/m ：273/m














init/en (/w )/w 方法/n
需求/n ：/w 在/d 上一/nz 小节/n 的/u demo/n 中/f ，/w 我们/r 已经/d 给/v BMW/n 这个/r 对象/n 添加/v 了/dg 2/m 个/q 属性/n ，/w wheelNum/en （/w 车/np 的/u 轮胎/np 数量/n ）/w 以及/c color/en （/w 车/np 的/u 颜色/n ）/w ，/w 试想/v 如果/c 再次/d 创建/v 一个/mq 对象/n 的话/u ，/w 肯定/a 也/d 需要/n 进行/v 添加/v 属性/n ，/w 显然/a 这样/r 做/v 很/d 费事/a ，/w 那么/c 有没有/vmv 办法/n 能够/v 在/d 创建/v 对象/n 的/u 时候/n ，/w 就/d 顺便/d 把/p 车/np 这个/r 对象/n 的/u 属性/n 给/v 设置/v 呢/ng ？/w
答案/n init/en (/w )/w 方法/n
“/w 魔法/n ”/w 方法/n
总结/n
在/d python/en 中方/n 法名/n 如果/c 是/v xxxx/en (/w )/w 的/u ，/w 那么/c 就/d 有/v 特殊/a 的/u 功能/n ，/w 因此/c 叫做/v “/w 魔法/n ”/w 方法/n
当/ag 使用/v print/en 输出/v 对象/n 的/u 时候/n ，/w 只要/c 自己/r 定义/n 了/dg str/en (/w self/en )/w 方法/n ，/w 那么/c 就/d 会/n 打印/v 从/p 在/d 这个/r 方法/n 中/f return/en 的/u 数据/n
理解/v self/en
总结/n
所谓/b 的/u self/en ，/w 可以/a 理解/v 为/p 自己/r
可以/a 把/p self/en 当做/v C++/n 中/f 类/n 里面/f 的/u this/en 指针/n 一样/a 理解/v ，/w 就是/n 对象/n 自身/r 的/u 意思/n
某个/r 对象/n 调用/v 其/r 方法/n 时/n ，/w python/en 解释器/n 会/n 把/p 这个/r 对象/n 作为/n 第一/m 个/q 参数/n 传递/v 给/v self/en ，/w 所以/c 开发者/n 只需/n 要/v 传递/v 后面/f 的/u 参数/n 即可/v
总结/n ：/w 如果/c 一个/mq 对象/n 与/c 另外/c 一个/mq 对象/n 有/v 一定/b 的/u 关系/n ，/w 那么/c 一个/mq 对象/n 可用/a 是/v 另外/c 一个/mq 对象/n 的/u 属性/n
保护/v 对象/n 的/u 属性/n
如果/c 有/v 一个/mq 对象/n ，/w 当/ag 需要/n 对/a 其/r 进行/v 修改/v 属性/n 时/n ，/w 有/v 2/m 种/ng 方法/n 对象/n 名/n ./m 属性/n 名/n =/0 数据/n ----/t >/w 直接/a 修改/v 对象/n 名/n ./m 方法/n 名/n (/w )/w ----/t >/w 间接/b 修改/v 为了/p 更好/d 的/u 保存/v 属性/n 安全/a ，/w 即/c 不能/v 随意/a 修改/v ，/w 一般/a 的/u 处理/v 方式/n 为/p
将/d 属性/n 定义/n 为/p 私有/v 属性/n
添加/v 一个/mq 可以/a 调用/v 的/u 方法/n ，/w 供/ng 调用/v
总结/n
Python/en 中/f 没有/d 像/n C++/n 中/f public/en 和/c private/en 这些/r 关键字/n 来/u 区别/n 公有/b 属性/n 和/c 私有/v 属性/n
它/r 是以/c 属性/n 命名/v 方式/n 来/u 区分/v ，/w 如果/c 在/d 属性/n 名/n 前面/f 加/ng 了/dg 2/m 个/q 下划线/n ’/w _/0 _/0 ’/w ，/w 则/c 表明/v 该/r 属性/n 是/v 私有/v 属性/n ，/w 否则/c 为/p 公有/b 属性/n （/w 方法/n 也/d 是/v 一样/a ，/w 方法/n 名/n 前面/f 加/ng 了/dg 2/m 个/q 下划线/n 的话/u 表示/v 该/r 方法/n 是/v 私有/v 的/u ，/w 否则/c 为/p 公有/b 的/u ）/w 。/w
del/en (/w )/w 方法/n
创建/v 对象/n 后/f ，/w python/en 解释器/n 默认/v 调用/v init/en (/w )/w 方法/n ；/w
当/ag 删除/v 一个/mq 对象/n 时/n ，/w python/en 解释器/n 也/d 会/n 默认/v 调用/v 一个/mq 方法/n ，/w 这个/r 方法/n 为/p del/en (/w )/w 方法/n
del/en 程序/n 结束/v 后/f 自动/b 会/n 调用/v
总结/n :/w
当/ag 有/v 1/m 个/q 变量/n 保存/v 了/dg 对象/n 的/u 引用/v 时/n ，/w 此/r 对象/n 的/u 引用/v 计数/v 就/d 会/n 加/ng 1/m
当/ag 使用/v del/en 删除/v 变量/n 指向/v 的/u 对象/n 时/n ，/w 如果/c 对象/n 的/u 引用/v 计数/v 不会/v 1/m ，/w 比如/v 3/m ，/w 那么/c 此时/r 只/bg 会/n 让/v 这个/r 引用/v 计数/v 减/v 1/m ，/w 即/c 变为/v 2/m ，/w 当/ag 再次/d 调用/v del/en 时/n ，/w 变为/v 1/m ，/w 如果/c 再/d 调用/v 1/m 次/a del/en ，/w 此时/r 会/n 真的/d 把/p 对象/n 进行/v 删除/v
单/b 继承/v

继承/v 的/u 概念/n
虽然/c 子类/n 没有/d 定义/n init/en 方法/n ，/w 但是/c 父/ng 类/n 有/v ，/w 所以/c 在/d 子类/n 继承/v 父/ng 类/n 的/u 时候/n 这个/r 方法/n 就/d 被/ng 继承/v 了/dg ，/w 所以/c 只要/c 创建/v Bosi/en 的/u 对象/n ，/w 就/d 默认/v 执行/v 了/dg 那个/r 继承/v 过来/v 的/u init/en 方法/n

重写/v 、/w
调用/v 父/ng 类/n 方法/n 所谓/b 重写/v ，/w 就是/n 子类/n 中/f ，/w 有/v 一个/mq 和/c 父/ng 类/n 相同/a 名字/n 的/u 方法/n ，/w 在/d 子类/n 中/f 的/u 方法/n 会/n 覆盖/v 掉/v 父/ng 类/n 中/f 同名/v 的/u 方法/n
静态/n 方法/n 和/c 类/n 方法/n
1/m 、/w 类/n 方法/n 是/v 类/n 对象/n 所/n 拥有/v 的/u 方法/n ，/w 需要/n 用/ng 修饰/v 器/k @/w classmethod/en 来/u 标识/n 其/r 为/p 类/n 方法/n ，/w 对于/p 类/n 方法/n ，/w 第一/m 个/q 参数/n 必须/d 是/v 类/n 对象/n ，/w 一般/a 以/p cls/en 作为/n 第一/m 个/q 参数/n （/w 当然/b 可以/a 用/ng 其他/r 名称/n 的/u 变量/n 作为/n 其/r 第一/m 个/q 参数/n ，/w 但是/c 大部分/n 人/n 都/d 习惯/n 以/p ’/w cls/en ’/w 作为/n 第一/m 个/q 参数/n 的/u 名字/n ，/w 就/d 最好/d 用/ng ’/w cls/en ’/w 了/dg ）/w ，/w 能够/v 通过/p 实例/n 对象/n 和/c 类/n 对象/n 去/v 访问/v 。/w
类/n 方法/n 还有/v 一个/mq 用途/n 就是/n 可以/a 对/a 类/n 属性/n 进行/v 修改/v ：/w
结果/c 显示/v 在用/b 类/n 方法/n 对/a 类/n 属性/n 修改/v 之后/f ，/w 通过/p 类/n 对象/n 和实/nz 例/n 对象/n 访问/v 都/d 发生/v 了/dg 改变/v
类/n 方法/n
需要/n 通过/p 修饰/v 器/k @/w staticmethod/en 来/u 进行/v 修饰/v ，/w 静态/n 方法/n 不/d 需要/n 多/a 定义/n 参数/n
总结/n
从/p 类/n 方法/n 和实/nz 例/n 方法/n 以及/c 静态/n 方法/n 的/u 定义/n 形式/n 就/d 可以/a 看出/v 来/u ，/w 类/n 方法/n 的/u 第一/m 个/q 参数/n 是/v 类/n 对象/n cls/en ，/w 那么/c 通过/p cls/en 引用/v 的/u 必定/d 是/v 类/n 对象/n 的/u 属性/n 和/c 方法/n ；/w 而/c 实例/n 方法/n 的/u 第一/m 个/q 参数/n 是/v 实例/n 对象/n self/en ，/w 那么/c 通过/p self/en 引用/v 的/u 可能/a 是/v 类/n 属性/n 、/w 也/d 有/v 可能/a 是/v 实例/n 属性/n （/w 这个/r 需要/n 具体/a 分析/v ）/w ，/w 不过/c 在/d 存在/v 相同/a 名称/n 的/u 类/n 属性/n 和实/nz 例/n 属性/n 的/u 情况/n 下/f ，/w 实例/n 属性/n 优先级/n 更/d 高/a 。/w 静态/n 方法/n 中/f 不/d 需要/n 额外/b 定义/n 参数/n ，/w 因此/c 在/d 静态/n 方法/n 中/f 引用/v 类/n 属性/n 的话/u ，/w 必须/d 通过/p 类/n 对象/n 来/u 引用/v
