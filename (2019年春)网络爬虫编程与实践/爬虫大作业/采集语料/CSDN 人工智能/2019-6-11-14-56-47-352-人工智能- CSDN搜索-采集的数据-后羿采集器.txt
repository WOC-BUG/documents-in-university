标题,标题链接,search-detail,limit_width1,https,作者,日期,https1,down,详情标题,日期时间,内容
人工智能,https://blog.csdn.net/qq_43167223/article/details/83626480,Python 中的单例n* 单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例n 1. nni.定义一个 类属性，初始值是 None，用于记录 单例对象的引用n2.nii.重写 new 方法n3.niii.如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果n4.niv.返回 类属性 中记录的 对象引用n只执行一次初始化工作n在每次使用 类名() 创建对象时，Pyt...,https://blog.csdn.net/qq_43167223/article/details/83626480,,qq_43167223,2018-11-01,//blog.csdn.net/qq_43167223/article/details/83626480,56次阅读,人工智能 - qq_43167223的博客,2018年11月01日 20:32:09,原        人工智能
      
      
        
                                                  2018年11月01日 20:32:09
          芜杂栾雨，芜杂銮舆
          阅读数：57
                  
        
                  
      
    
  
  
    
            
                              
            
            
              
            
            Python 中的单例
* 单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例
	1. 
1
i.定义一个 类属性，初始值是 None，用于记录 单例对象的引用
2.
ii.重写 new 方法
3.
iii.如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果
4.
iv.返回 类属性 中记录的 对象引用
只执行一次初始化工作
在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：
new 分配空间
init 对象初始化
在上一小节对 new 方法改造之后，每次都会得到 第一次被创建对象的引用
但是：初始化方法还会被再次调用
需求
让 初始化动作 只被 执行一次
解决办法
1.
定义一个类属性 init_flag 标记是否 执行过初始化动作，初始值为 False
2.
在 init 方法中，判断 init_flag，如果为 False 就执行初始化动作
3.
然后将 init_flag 设置为 True
4.
这样，再次 自动 调用 init 方法时，初始化动作就不会被再次执行 了
捕捉异常我们学习上之路一路走来。。。啊，不对，我们一直在这个教室上课
遇到了很多运行后报错
报错了，也就是发生了异常情况！
有时候我们想让系统提供更具体的异常信息，帮助我们解决问题
有时候我们想忽略本次异常，让程序继续执行下去
那我们该怎么办呢？
怎么办爱情甜又酸
思绪收回【咻的一下】
在Python中，我们将可能出现异常的代码放在 ’ 隔离区 ’ 里运行
这样的话，出了问题不会影响其他部分
try…except…
那怎么创建一个隔离区呢？
在Python中使用try…except 结构创建 ’ 隔离区 ‘，也就是进行异常处理
try 包含的部分是放入可能出现异常的代码
except 部分是来处理发生的异常
结构是：
try：
可能引起异常的代码
except：
对异常的处理代码
test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。
我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。
异常的传递
1、try嵌套中
总结：
如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。
如果一个异常是在一个函数中产生的，例如函数A—->函数B—->函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样
注意观察上中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行
抛出自定义的异常
你可以用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类
这一行代码，可以调用也可以不调用，建议调用，因为init方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的init方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的init方法，最好是先调用父类的这个方法，然后再添加自己的功能
模块
1、Python中的模块有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include <math.h>引入math.h这个头文件，否则是无法正常进行调用的。
那么在Python中，如果要引用一些其他的函数，该怎么处理呢？
在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。
说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块
import在Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。形如：
import module1,mudule2…
当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。
通过这种方式引入的时候，调用函数时只能给出函数名，不能给出模块名，但是当两个模块中含有相同名称函数的时候，后面一次引入会覆盖前一次引入。也就是说假如模块A中有函数function( )，在模块B中也有函数function( )，如果引入A中的function在先、B中的function在后，那么当调用function函数的时候，是去执行模块B中的function函数。
如果想一次性引入math中所有的东西，还可以通过from math import *来实现
from…importPython的from语句让你从模块中导入一个指定的部分到当前命名空间中
from … import *把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
6定位模块当你导入一个模块，Python解析器对模块位置的搜索顺序是：
当前目录
*
如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。
*
如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/
*
模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录
模块制作
1、定义自己的模块在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。
比如有这样一个文件test.py，在test.py中定义了函数add
test.py
2调用自己定义的模块那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入
main.py
3测试模块在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如：
test.py
工厂模式
1、简单工厂模式最后来看看工厂方法模式的定义定义了一个创建对象的接口(可以理解为函数)，但由子类决定要实例化的类是哪一个，工厂方法模式让类的实例化推迟到子类，抽象的CarStore提供了一个创建对象的方法createCar，也叫作工厂方法。
子类真正实现这个createCar方法创建出具体产品。 创建者类不需要直到实际创建的产品是哪一个，选择了使用了哪个子类，自然也就决定了实际创建的产品是什么。
模块中的__all__
没有__all__的情况
有__all__的情况
