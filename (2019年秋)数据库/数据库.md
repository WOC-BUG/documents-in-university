## MySQL常用数据类型

| 数据类型                          | 描述                                                |
| :-------------------------------- | :-------------------------------------------------- |
| CHAR(n)，CHARACTER(n)             | 字符/字符串，固定长度 n                             |
| VARCHAR(n) ，CHARACTER VARYING(n) | 字符/字符串，可变长度，最大长度 n                   |
| CLOB                              | 字符串大对象                                        |
| BINARY(n)                         | 二进制串，固定长度 n                                |
| VARBINARY(n) 或 BINARY VARYING(n) | 二进制串，可变长度，最大长度 n                      |
| BLOB                              | 二进制大对象                                        |
| BOOLEAN                           | 存储 TRUE 或 FALSE 值                               |
| INT，INTEGER(p)                   | 长整数，4字节                                       |
| SMALLINT                          | 短整数，2字节                                       |
| BIGINT                            | 大整数，8字节                                       |
| DECIMAL(p,s)，DEC(p,s)            | 定点数，p位数（不包括符号、小数点），小数点后位数 s |
| NUMERIC(p,s)                      | 同上                                                |
| FLOAT(p)                          | 近似数值，精度至少为p位数字                         |
| REAL                              | 近似数值，单精度浮点数，尾数精度 7                  |
| DOUBLE PRECISION                  | 近似数值，双精度浮点数，尾数精度 16                 |
| DATE                              | 存储年、月、日的值，格式为 YYYY-MM-DD               |
| TIME                              | 存储时、分、秒的值，格式为 HH:MM:SS                 |
| TIMESTAMP                         | 时间戳类型，存储年、月、日、小时、分、秒的值        |
| INTERVAL                          | 由一些整数字段组成，代表一段时间，取决于区间的类型  |
| ARRAY                             | 元素的固定长度的有序集合                            |
| MULTISET                          | 元素的可变长度的无序集合                            |
| XML                               | 存储 XML 数据                                       |

# 第一篇 基础篇



## 第一章 绪论

---

### 1.1 数据库系统概论

#### 1.1.1 四个基本概念

* **数据（data）**

**定义：**描述事物的符号记录

* **数据库**

**定义：**以一定的组织方式将相关数据组织在一起存储在磁盘上所形成的、能为多个用户共享的、与应用程序彼此独立的一组相互关联的数据的集合。

* **数据库管理系统（DBMS）**

**定义：**用于管理数据库，完成对数据库的一切操作，包括定义、查询、更新以及各种控制的软件系统。

**基本功能：**

1. 数据定义——提供数据定义语言(DDL，Data Definition Language)，定义数据库中的数据对象。
2. 数据操纵——提供数据操纵语言（DML，Data Manipulation Language）操纵数据，实现对数据库的基本操作(查询、插入、删除和修改)。
3. 数据控制——保证数据的安全性、完整性、多用户对数据的并发使用,发生故障后的系统恢复。
4. 数据管理和维护——数据库的初始数据的装入、数据库转储、数据库的重组织及性能监视等。

* **数据库系统（DBS）**

  **定义：**在计算机系统中引入数据库后的系统，由三部分组成：数据库(DB)、数据库管理系统(DBMS及其开发工具)和数据库应用。

#### 1.1.2 数据库管理技术的产生和发展

1. 人工管理阶段
2. 文件系统阶段
3. 数据库系统阶段

#### 1.1.3 数据库系统的特点

* 面向全组织的数据结构化 
* 数据的共享性提高 
* 数据独立性高(物理独立性、逻辑独立性)
* 数据保存在数据库中，由DBMS统一管理和控制 
  1. 数据的安全性保护
  2. 数据的完整性检查
  3. 并发控制
  4. 数据库恢复

### 1.2 数据模型

#### 1.2.1 两类数据模型

* **概念模型（信息模型）**
* **逻辑模型和物理模型**

#### 1.2.2 概念模型

1. **实体：**客观存在并可以相互区别的事物。可指人或实际的东西，也可指概念性的东西。
   如：一个学生、一辆吉普车、一次演出等

2. **属性：**实体所具有的某一特征。一个实体可由若干个属性来刻画。
   如：学生实体有学号、姓名、年龄、性别、系、入学时间…等属性
3. **域：**属性的取值范围
   如：学号  (8位整数)、性别  (男/女)
4. **实体型：**用实体名及其属性名集合来抽象和刻画同类实体
     格式：实体名(属性名1，属性名2，…)
     如：学生(学号，姓名，年龄，性别，…)
5. **实体键/码：**能够把某个实体个体与其他实体个体区分开来，即能唯一标识一个实体的属性或属性集合。
     如：学生实体中的“学号”属性
6. **实体集：**性质相同的同型实体的集合。
   如：全体学生、所有吉普车、所有演出等

7. **联系：**现实世界事物之间的联系也同样要抽象和反映到信息世界来，在信息世界中将被抽象为：
   实体(型)内部之间的联系（即属性间的联系）
   各种实体(型)之间的联系（即实体之间的联系）

实体-联系方法：简称E-R模型

* 1：1
* 1：N
* M：N

#### 1.2.3 数据模型的组成要素

1. **数据结构：**数据对象类型(Type)的集合
2. **数据操作：**对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则
3. **数据的完整性约束条件：**一组完整性规则的集合

#### 1.2.4 数据模型的分类

1. **层次模型**

   特征：

   * 结点的双亲是唯一的
   * 只能直接处理一对多的实体联系
   * 每个记录类型可以定义一个排序字段，也称为码字段
   * 任何记录值只有按其路径查看时，才能显出它的全部意义
   * 没有一个子女记录值能够脱离双亲记录值而独立存在

2. **网状模型**

   特征： 

   * 有一个以上的结点没有双亲
   * 至少有一个结点可以有多于一个双亲

3. **关系模型**

   1. 关系（Relation）：一个关系对应通常说的一张表
   2. 元组（Tuple）：表中的一行即为一个元组
   3. 属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名
   4. 主码（Key）：也称码键。表中的某个属性组，它可以唯一确定一个元组
   5. 域（Domain）：是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。
   6. 分量：元组中的一个属性值。
   7. 关系模式（Schema）：对关系的描述
   8. 关系名（属性1，属性2，…，属性n）：学生（学号，姓名，年龄，性别，系名，年级）

### 1.3 数据库系统的结构

#### 1.3.1数据库系统模式的概念

* 型（Type）:对某一类数据的结构和属性的说明
* 值（Value）:是型的一个具体赋值

**例如**
学生记录：
（学号，姓名，性别，系别，年龄，籍贯）
一个记录值：
（201315130，李明，男，计算机系，19，江苏南京市）

**模式相对稳定，实例相对变动**



#### 1.3.2 数据库系统的三级模式结构

1. **模式：**数据库中全体数据的逻辑结构和特征的描述
   * 所有用户的公共数据视图
   * 一个数据库只有一个模式
2. **外模式：**数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示
3. **内模式：**是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式
   * 一个数据库只有一个内模式

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1571750520714.png" alt="数据库系统的三级模式结构" style="zoom:80%;" />

#### 1.3.3 数据库的二级映像功能与数据独立性

1. 外模式/模式映像
2. 模式/内模式映像



### 1.4 数据库系统的组成

1. 硬件
2. 软件
3. 人员



## 第二章 关系数据库

---



## 第三章 关系数据库标准语言SQL

---

### 3.1  SQL概述

### 3.2  学生-课程数据

### 3.3 数据定义

#### 3.3.1 模式的定义与删除

* **定义模式(只有SQLServer中有该语句)**

  <font color='#DA90D6'>create schema</font> [模式名(可省略)] <font color='#DA90D6'>authorization</font> [用户名] [创建表语句(可省略)]

```sql
-- 为用户zhang创建模式test，并在其中定义表Tab1
create schema test authorization Zhang
create table tab1(col1 smallint,
                  col2 int,
                  col3 char(20),
                  col4 numeric(10,3),
                  col5 decimal(5,2));
```

* **删除模式**

  <font color='#DA90D6'>drop schema</font> [模式名] [<font color='#DA90D6'> cascade</font> / <font color='#DA90D6'> restrict </font>]

  <font color='#DA90D6'>cascade</font>（级联）：删除模式并清空数据库对象

  <font color='#DA90D6'>restict</font>（限制）：若模式中已有数据库对象（表/视图/...），则拒绝删除语句的执行

```sql
-- 删除模式Zhang
drop schema Zhang cascade;
```



#### 3.3.2 基本表的定义与删除

**学生表：**Student ( Sno , Sname , Ssex , Sage , Sdept ) —— 学号，姓名，性别，年龄，所在系

**课程表：**Course ( Cno , Cname , Cpno , Ccredit ) —— 课程号，课程名，先行课，学分

**学生选课表：**SC ( Scno , Cno , Grade ) —— 学号，课程号，成绩

```sql
-- 建立学生表
create table student(
Sno char(12) primary key,
Sname char(20) unique,
Ssex char(2),
Sage smallint,
Sdept char(20)
);

-- 建立课程表
create table course(
Cno char(4) primary key,
Cname char(40) not null,
Cpno char(4),
Ccredit smallint,
foreign key (Cpno) references course (Cno)
    -- 建立外键Cpno，被参照表是course
);
```



#### 找出每个学生超过他选修课程平均成绩的课程号

* 法一：

```sql
-- 先求课程平均值，并起别名为avgGrade分组制表
select distinct Sno,AVG(Grade) avgGrade
from SC
group by Sno;
-- 再对它们做连接，按照要求做选择
select Sno,Cno
from SC,avgGrade
where Sc.Sno=avgGrade.Sno
and avgGrade<Sc.Grade;
```

* 法二：

```sql
SELECT Sno, Cno
FROM SC x
WHERE Grade > (SELECT AVG(Grade)
FROM SC
WHERE Sno = x.Sno )
```



#### 3.4.4  集合查询

* UNION（并）
* INTERSECT（交，Mysql中没有）
* EXCEPT（差，Mysql中没有，可以用not in）



例：查询选修了1024但没有选修1136的学生

```sql
SELECT Sno
FROM SC
WHERE Cno= '1024'
EXCEPT
SELECT Sno
FROM SC
WHERE Cno= '1136'
```



### 3.7  视图

####  3.7.1 定义视图

数据库只存放视图的定义，而不包含数据，可以通过视图查询，极少用于插入更改删除。

<b>格式：</b>

``` sql
CREATE VIEW <视图名> [(<列名>[, <列名>]…)]
AS <子查询>
[WITH CHECK OPTION];
-- <子查询>可以是任意复杂的SELECT语句，但通常不允许含有ORDER BY子句和DISTINCT短语
```

<b>视图种类</b>

* 单表视图：一个基本表的行列子集

```sql
-- 建立计算机系学生的视图
CREATE VIEW Student_CS
AS
SELECT Sno, Sname, Sage,Sdept
FROM Student
WHERE Sdept= '计算机'
-- DBMS执行CREATE VIEW语句的结果只是把视图的定义存入数据字典，并不执行其中的SELECT语句。只有在对视图查询时，才按视图的定义从表中将数据取出。
```

* 多表视图

```sql
-- 建立1156（英语课）的学生成绩单视图，包括学号、姓名和分数。
CREATE VIEW English_Grade(学号, 姓名, 英语分数)
AS
SELECT Student.Sno, Sname, Grade
FROM Student, SC
WHERE Student.Sno=SC.Sno
AND SC.Cno= '1156'
```

* 视图的视图

```sql
-- 建立英语课的成绩在90分以上的学生的视图。
CREATE VIEW English_Grade_90
AS
SELECT 学号, 姓名, 英语分数
FROM English_Grade
WHERE 英语分数>=90
```

* 虚拟列视图：带表达式/计算视图

```sql
-- 定义一个反映学生出生年份的视图。
CREATE VIEW BT_S(Sno, Sname, Sbirth)
AS
SELECT Sno, Sname, YEAR(GETDATE( ))-Sage
FROM Student
-- 视图中的出生年份值是通过计算得到的，必须给出列名或在子查询中使用别名。
```

* 分组视图：含GROUP子句及聚集函数

```sql
-- 将学生的学号及其平均成绩定义为一个视图
CREATE VIEW S_G(Sno, Gavg)
AS
SELECT Sno, AVG(Grade)
FROM SC
GROUP BY Sno
-- 由于AS子句中SELECT语句的目标列平均成绩是通过作用聚集函数得到的，所以CREATE VIEW中必须明确定义组成S_G视图的各个属性列名，S_G是一个分组视图。
```



<b>删除视图</b>

格式：

```sql
DROP VIEW <视图名>
```

例：

```sql
-- 删除视图Student_CS
DROP VIEW Student_CS
-- 一次可删除多个视图
DROP VIEW BT_S, F_Student
```



#### 3.7.2 查询视图

<b>视图消解法</b>

```sql
-- 在计算机系学生的视图中找出年龄小于19岁的学生。
SELECT Sno, Sage
FROM Student_CS
WHERE Sage<19
-- 视图消解（View Resolution）后的查询语句为：
SELECT Sno, Sage
FROM Student
WHERE Sdept= '计算机' AND Sage< 19
```



查询每个学生超过他选修课程平均成绩的课程号
方法一：用相关嵌套查询

```sql
SELECT Sno, Cno
FROM SC x
WHERE Grade > (SELECT AVG(Grade)
FROM SC
WHERE Sno = x.Sno )
```
方法二：
```sql
-- 可先定义一个视图，求出每个学生的课程平均成绩：
CREATE VIEW AVGRADE
AS
SELECT Sno, AVG(Grade) AvgGrade
FROM SC
GROUP BY Sno
-- 然后用如下的查询语句完成查询：
SELECT SC.Sno,Cno
FROM SC, AVGRADE v
WHERE SC.Sno = v.Sno
AND SC.Grade> v.AvgGrade
-- 这比用相关嵌套查询表达更容易理解
```

视图消解以后的语句

```sql
SELECT SC.Sno, Cno
FROM SC,
( SELECT Sno, AVG(Grade) AvgGrade
FROM SC
GROUP BY Sno ) v
WHERE SC.Sno = v.Sno
AND SC.Grade > v.AvgGrade
```



#### 3.7.3 更新视图





## 第四章 数据库安全性

---

本章要求

* 知道TCSEC是什么，知道它之后的三个标准CTCPEC、ITSEC、FC,知道CC是安全评估主要标准

* 知道自主存取控制方法、强制存取控制方法两个词的含义



要知道标准是干什么的，不需要知道详细定义

知道自主存取控制、强制存储控制两个词是干什么的

### 4.1 数据库安全性概述

![1573544482757](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1573544482757.png)





TCSEC/TDI安全级别划分
4组（division）7个等级

* D

* C（C1，C2）

  C1级能够实现对用户和数据的分离，进行自主存取控制（ Discretionary Access Control , DAC），保护或限制用户权限的传播。

* B（B1，B2，B3）

  达到B1级，即可标为“安全”、“可信”产品

* A（A1）
  按系统可靠或可信程度逐渐增高
  各安全级别之间具有一种**偏序向下兼容**的关系，即较高安全性级别提供的安全保护要包含较低级别的所有保护要求，同时提供更多或更完善的保护能力



### 4.2 数据库安全性控制

**存储控制**

常用存取控制方法

1. 自主存取控制（Discretionary Access Control ，简称DAC）
   C2级
   用户对不同的数据对象有不同的存取权限
   不同的用户对同一对象也有不同的权限
   用户还可将其拥有的存取权限转授给其他用户

2. 强制存取控制（Mandatory Access Control，简称 MAC）
   B1级
   每一个数据对象被标以一定的密级
   每一个用户也被授予某一个级别的许可证
   对于任意一个对象，只有具有合法许可证的用户才可以存取



**授权：授予与回收**

1.GRANT
GRANT语句的一般格式：
GRANT <权限>[,<权限>]... 
ON <对象类型> <对象名>[,<对象类型> <对象名>]…
TO <用户>[,<用户>]...
[WITH GRANT OPTION];
语义：将对指定操作对象的指定操作权限授予指定的用户 



发出GRANT：

* 数据库管理员
* 数据库对象创建者（即属主Owner）
* 拥有该权限的用户

接受权限的用户 

* 一个或多个具体用户
* PUBLIC（即全体用户） 



WITH GRANT OPTION子句:

* 指定：可以再授予
* 没有指定：不能传播

不允许循环授权：被授权者不能把权限再授回给授权者或其祖先



[例1] 把查询Student表权限授给用户U1

```sql
GRANT   SELECT 
ON Student 
TO   'u1'@'localhost';
```



[例2] 把对Student表和Course表的全部权限授予用户U2和U3

      ```sql
GRANT ALL --PRIVILIGES 
ON Student,Course 
TO U2,U3;
      ```



*[例3] 把对表SC的查询权限授予所有用户（仅SQL Server能用）

```sql
GRANT SELECT 
ON  SC 
TO PUBLIC;
```



​     

[例4] 把查询Student表和修改学生学号的权限授给用户U4

```sql
GRANT UPDATE(Sno), SELECT 
ON Student 
TO U4;
-- 对属性列的授权时必须明确指出相应属性列名 ，update哪一列
```



[例5] 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户

```sql
GRANT INSERT 
ON SC 
TO U5
WITH GRANT OPTION;
```



执行例5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限：
 [例6]  

```sql
 GRANT INSERT
 ON SC 
 TO U6
 WITH GRANT OPTION;
```



同样，U6还可以将此权限授予U7：
 [例7]   

```sql
GRANT INSERT 
ON SC
TO U7;
```




​      但U7不能再传播此权限。

执行了例1~例7语句后学生-课程数据库中的用户权限定义表 ：

| **授权用户名** | **被授权用户名** | **数据库对象名**          | **允许的操作类型** | **能否转授权** |
| -------------- | ---------------- | ------------------------- | ------------------ | -------------- |
| **DBA**        | **U1**           | **关系****Student**       | **SELECT**         | **不能**       |
| **DBA**        | **U2**           | **关系****Student**       | **ALL**            | **不能**       |
| **DBA**        | **U2**           | **关系****Course**        | **ALL**            | **不能**       |
| **DBA**        | **U3**           | **关系****Student**       | **ALL**            | **不能**       |
| **DBA**        | **U3**           | **关系****Course**        | **ALL**            | **不能**       |
| **DBA**        | **PUBLIC**       | **关系****SC**            | **SELECT**         | **不能**       |
| **DBA**        | **U4**           | **关系****Student**       | **SELECT**         | **不能**       |
| **DBA**        | **U4**           | **属性列****Student.Sno** | **UPDATE**         | **不能**       |
| **DBA**        | **U5**           | **关系****SC**            | **INSERT**         | **能**         |
| **U5**         | **U6**           | **关系****SC**            | **INSERT**         | **能**         |
| **U6**         | **U7**           | **关系****SC**            | **INSERT**         | **不能**       |

### *4.3 视图

### 4.4 审计

### *4.5 数据加密

### *4.6其他安全性保护





## 第五章 数据库完整性

---

正确性+相容性

# 第二篇 设计应用开发篇

## 第六章 关系数据理论

---

### 6.1 问题的提出

**关系模式由五部分组成**

R：      关系名
U：       组成该关系的属性名集合
D：       属性组U中属性所来自的域
DOM： 属性向域的映象集合
F：       属性间数据的依赖关系集合



数据依赖有函数依赖（Functional Dependency，FD）、多值依赖（Multivalued Dependency，MVD）和连接依赖等。

<font color='red'>函数依赖很重要，必须掌握，期末必考</font>，多值和连接依赖了解即可。

### 6.2 规范化

**函数依赖**

**定义1** 

* 设关系模式R(A 1 ,A 2 ,…，A n ),X,Y是R的两个属性集合，X      {A 1 ,A 2 ,…，A n }及Y     {A 1 ,A 2 ,…，A n }，R[X,Y]是关系R在属性X∪Y上的投影
* 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X 函数确定 Y” 或  “Y 函数依赖于 X”，记作X→Y。
* 当X →Y，但Y     X，则称X →Y是非平凡的函数依赖，反之则为平凡函数依赖
* 当Y不函数依赖于X，则记作X → Y。
* 若X →Y，则称X为这个函数依赖的决定属性组
* 当X → Y，Y → X时，则记作X ↔ Y  

例：

```sql
School(Sno,Sname,Ssex,Sage,Sdept,Dhead, ……)
              X      Y
```

因为：一个学号只对应一个学生
所以：Sno → Sname
即：姓名Sname函数依赖于学号Sno或学号函数决定姓名
类似于数学中的函数Y=F(X) ， Sname=F(Sno)
同理：Sno → Ssex 、 Sno → Sage ……

**依赖关系**

1. 在一个关系模式中，如果属性X与Y有1:1联系时，则存在函数依赖X→Y，Y→X，即X ↔ Y。
   例如，当学生无重名时，Sno ↔ Sname
2. 如果属性X与Y有m:1的联系时，则存在函数依赖X→Y。
   例如， Sno 与Sage ， Sdept 之间均为m:1 联系， 所以有Sno→Sage，Sno→Sdept
3. 如果属性X与Y有m:n的联系时，则X与Y之间不存在任何函数依赖关系。



**定义2**

设关系模式R(X,Y),X,Y是R的属性集，当对X的每一个真子集X'都有X' → Y,则Y对X的函数依赖是完全的，记作X --F->  Y 。

**定义3**

 设X,Y,Z为关系模式R(U)的互不相同的属性集合，如果X → Y,而Y --/-> X，但Y → Z，则称Z传递函数依赖于X
记作 X--t->Z。

当条件 Y --/-> X 不成立时， 即 Y → X ， 则X ↔ Y，实际上X → Z是直接函数依赖，而
非传递函数依赖。

**定义4**
设K为关系模式R<U,F>中的属性或属性组合。若K--f->U（即全体属性完全函数依赖于 K ） ， 则 K 称为 R 的一个 侯选码（Candidate Key）。
若关系模式R有多个候选码，则选定其中的一个做为主码（Primary key）。
如果是部分函数依赖的话，则K为超码
候选码中的属性成为主属性，极端情况整个属性组是码，则成为全码

**定义5**
关系模式R中属性或属性组X并非R的码，但是另外一个关系模式的码，则称X是R的外部码



**第一范式(1NF-First Normal Form)**：关系R属于第一范式，当且仅当R中每一个属性A的值域只包含<font color='red'>原子项</font>。

**第二范式(2NF)**：若关系模式R∈1NF，且<font color='red'>每个</font>非主属性都<font color='red'>完全函数依赖于</font>R的每个候选码（包括主码），则关系模式R属于第二范式（记作 R∈2NF ）。

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574152698082.png" alt="1574152698082" style="zoom:50%;" />

<table><tr>
    <td>
        <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574152745342.png" alt="1574152745342" style="zoom:50%;" align='left'/>
     </td>
    <td>
        <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574152755096.png" alt="1574152755096" style="zoom:50%;" align='left'/>
    </td>
    <td>
    <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574152763342.png" alt="1574152763342" style="zoom:50%;" align='left'/>
    </td>
    </tr>
</table>

**第三范式(3NF)** ：若关系模式R∈2NF，且每个非主属性都不传递函数依赖于R的候选码，则关系R属于第三范式（ R∈3NF ）。

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574153431773.png" style="zoom:50%;" />

<table><tr>
    <td>
        <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574165374533.png" alt="1574165374533" style="zoom:50%;" align='left'/>
     </td>
    <td>
        <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1574165919696.png" alt="1574165919696" style="zoom:50%;" align='left'/>
    </td>
    </tr>
</table>





---



## 第八章 数据库编程

---



# 第三篇 系统篇

## 第九章 关系查询处理和查询优化

---



## 第十章 数据库恢复技术

---



## 第十一章 并发控制

---



## 第十二章 数据库管理系统

---



# 第四篇 新技术篇

## 第十三章 数据库技术发展概述

---



## 第十四章 大数据管理

---



## 第十五章 内存数据库系统

---



## 第十六章 数据仓库与联机分析处理技术

---





